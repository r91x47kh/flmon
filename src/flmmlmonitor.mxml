<?xml version="1.0" encoding="utf-8"?>

<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml"
                xmlns:flmml="com.txt_nifty.sketch.flmml.*"
                xmlns:flmon="net.vt6f3ohw.flmon.*"
                layout="absolute"
				frameRate="60"
				creationComplete="init();">
    <mx:Style>
        @namespace mx "http://www.adobe.com/2006/mxml";
        mx|TextArea {
            fontFamily: "_typewriter","ＭＳ ゴシック","平成角ゴシック","monospace";
            fontSize: 14pt;
        }
    </mx:Style>

	<mx:Script>
	  <![CDATA[
				import com.txt_nifty.sketch.flmml.MEvent;
				import com.txt_nifty.sketch.flmml.MStatus
				import com.txt_nifty.sketch.flmml.MML;
				import com.txt_nifty.sketch.flmml.MMLEvent;
				import com.txt_nifty.sketch.flmml.MSequencer;
				import flash.events.Event;
				import flash.events.KeyboardEvent;
				import flash.events.FocusEvent;
				import flash.ui.Keyboard;
				import flash.geom.Rectangle;
				import net.vt6f3ohw.flmon.PianoRoll;
				import flash.display.Graphics;
				import flash.display.Sprite;
				import flash.text.TextField;
				import net.vt6f3ohw.flmon.PianoRollItem;
				
				protected var m_timer:Timer;
			  
			  
				// 定数たち
				
				// Sprite製UI部品たち
				private var _rootSp_PRoll_ref:PianoRoll; // root となる Sprite
					private var _text_ref:TextField;
				private var _mask_PRoll_ref:Sprite; // マスク
				
				// カウンタたち
				private var frameCounter:uint = 0;
				
				// キー入力状態
				private var _isKeyPressed:Object = new Object(); // _isKeyPressed[Keyboard.XX] にキーの押下状態を保持

				public function init():void {
					var i:int; // for用
					  
					if (this.parameters["mml"] != undefined) // mmlパラメータが渡されていたらMML入力欄にそれを置いておく
						input.text = unescape(this.parameters["mml"]);

					player.addEventListener(MMLEvent.COMPILE_COMPLETE, setWarnings);
					player.addEventListener(MMLEvent.COMPLETE,         onComplete);
					player.addEventListener(MMLEvent.BUFFERING,        onBuffering);
					
					m_timer = new Timer(250*4, 0); // 「1秒ごとに」「無限回」繰り返す
					m_timer.addEventListener(TimerEvent.TIMER, onSecond);

					{ // UIの用意
						{ // 小節数表示部分のUIの準備
							;
						}
						{ // 鍵盤部分のUIの準備
							;
						}
						{ // ピアノロール部分のUIの準備
							/** [ユーティリティ関数] ピアノロールを (deltaX, deltaY) だけスクロールする*/
							var scroll:Function = function(deltaX:int, deltaY:int):void { // 共通する処理をまとめた関数
								var rect:Rectangle;
								{
									rect = _rootSp_PRoll_ref.scrollRect.clone();
									rect.x += deltaX;
									rect.y += deltaY;
									if (rect.x < 0) rect.x = 0; // 画面左端以降にスクロールしようとしていたらクリッピング
									if (rect.y < 0) rect.y = 0; // 画面上端以降にスクロールしようとしていたらクリッピング
									if (rect.y + rect.height > PianoRoll.PIANOROLL_HEIGHT) rect.y = PianoRoll.PIANOROLL_HEIGHT - rect.height; // 画面下端以降にスクロールしようとしていたらクリッピング
								}
								
								_rootSp_PRoll_ref.scrollRect = rect;
							};
							
							{ // 描画が mx:Image 外にはみ出さないように、mx:Image にマスクを設定
								var mask_PRoll:Sprite;
								{ // mask_PRoll の初期化
									mask_PRoll = new Sprite();
									mask_PRoll.cacheAsBitmap = true; // 描画結果（＝ビットマップ）をキャッシュして高速化
									mask_PRoll.graphics.beginFill(0x000000);
									mask_PRoll.graphics.drawRect(0, 0, pianoroll.width, pianoroll.height);
									mask_PRoll.graphics.endFill();
								}
								_mask_PRoll_ref = mask_PRoll;
								
								pianoroll.addChild(mask_PRoll); // マスクをかける位置は動的に変化するため、addChild しておかないとマスクの位置がズレるので注意
								pianoroll.mask = mask_PRoll;
							}
							{ // mx:Image の中に Sprite ツリーを投入
								var rootSp_PRoll:PianoRoll; // mx:Image の中で root となる Sprite
								{ // rootSp_PRoll の初期化
									rootSp_PRoll = new PianoRoll();
									rootSp_PRoll.scrollRect = new Rectangle(0, PianoRoll.SEMITONE_HEIGHT*36, pianoroll.width, pianoroll.height); // デフォルトのスクロール位置とビューポートのサイズを設定
									{ // rootSp_PRoll に子Sprite （テキスト）を追加
										var text:TextField;
										{
											text = new TextField();
											text.x = 20;
											text.y = 20;
										}
										_text_ref = text; // 参照のプール
										
										rootSp_PRoll.addChild(text);
									}
									rootSp_PRoll.addEventListener(Event.ENTER_FRAME, function(e:Event):void { // デバッグ用。フレームカウンタを表示
										//_text_ref.text = pianoroll.width.toString() + ", " + pianoroll.height.toString();
										_text_ref.text = (++frameCounter).toString();
										
										{ // ピアノロールのスクロール位置を更新											
											{
												var isScrolled:Boolean = false; // scrollRect が変化したかどうかを格納するBoolean
												
												// 各キーが押下状態にあったらスクロール
												if (_isKeyPressed[Keyboard.UP] != undefined && _isKeyPressed[Keyboard.UP]) { scroll(0, -20); isScrolled = true; }
												if (_isKeyPressed[Keyboard.DOWN] != undefined && _isKeyPressed[Keyboard.DOWN]) { scroll(0, 20); isScrolled = true; }
												if (_isKeyPressed[Keyboard.LEFT] != undefined && _isKeyPressed[Keyboard.LEFT]) { scroll(-20, 0); isScrolled = true; }
												if (_isKeyPressed[Keyboard.RIGHT] != undefined && _isKeyPressed[Keyboard.RIGHT]) { scroll(20, 0); isScrolled = true; }
												
												// scrollRect が変化していたら Event.SCROLL イベントを dispatch
												if(isScrolled){ rootSp_PRoll.dispatchEvent(new Event(Event.SCROLL)); }
											}
										}
									});
									rootSp_PRoll.addEventListener(Event.SCROLL, function(e:Event):void { // rootSp_PRoll.scrollRect が変化したときに呼ばれるハンドラ
										pianorollHScrollBar.scrollPosition = rootSp_PRoll.scrollRect.x;
										pianorollVScrollBar.scrollPosition = rootSp_PRoll.scrollRect.y;
									});
								}
								_rootSp_PRoll_ref = rootSp_PRoll; // 参照のプール
								
								pianoroll.addChild(rootSp_PRoll);
							}
							pianoroll.addEventListener(Event.RESIZE, function(e:Event):void { // ピアノロールのサイズが変わった場合に備えてイベントハンドラを設定
								{ // マスク矩形のサイズを更新
									_mask_PRoll_ref.graphics.clear();
									_mask_PRoll_ref.graphics.beginFill(0x000000);
									_mask_PRoll_ref.graphics.drawRect(0, 0, pianoroll.width, pianoroll.height);
									_mask_PRoll_ref.graphics.endFill();
								}
								{ // ピアノロールのビューポートのサイズを更新
									var rect:Rectangle;
									{
										rect = _rootSp_PRoll_ref.scrollRect.clone();
										rect.width = pianoroll.width;
										rect.height = pianoroll.height;
									}
									
									_rootSp_PRoll_ref.scrollRect = rect;
								}
								{ // 縦横スクロールバーの pageSize を更新（不要？）
									pianorollHScrollBar.pageSize = pianoroll.width;
									pianorollVScrollBar.pageSize = pianoroll.height;
								}
								{ // 縦横スクロールバーの maxScrollPosition を更新
									pianorollHScrollBar.maxScrollPosition = (PianoRoll.BEAT_WIDTH*4)*100 - pianoroll.width;
									pianorollVScrollBar.maxScrollPosition = PianoRoll.PIANOROLL_HEIGHT - pianoroll.height;
								}
							});
							pianoroll.addEventListener(KeyboardEvent.KEY_DOWN, function(e2:KeyboardEvent):void {
								_isKeyPressed[e2.keyCode] = true;
							});
							pianoroll.addEventListener(KeyboardEvent.KEY_UP, function(e2:KeyboardEvent):void {
								_isKeyPressed[e2.keyCode] = false;
							});
							pianoroll.addEventListener(MouseEvent.MOUSE_WHEEL, function(e3:MouseEvent):void {
								var delta:int = e3.delta; // ホイールの回転量

								scroll(0, PianoRoll.SEMITONE_HEIGHT * ( -delta )); // (半音の縦幅)*(ホイールの回転量)ずつスクロール（スクロールの向きは指を動かす方向と同じ）
								rootSp_PRoll.dispatchEvent(new Event(Event.SCROLL)); // Event.SCROLL イベントを dispatch
							});
							// TODO: キー押下状態中にフォーカスがどっか行ったときに備えて FocusEvent.OUT 時にキー押下状態を全部 false にするコードを追加
							// pianoroll.addEventListener(FocusEvent.FOCUS_OUT, function(e3:FocusEvent):void {
							// 	trace(e3);
							// });
						}
						{ // 縦横スクロールバーの scrollPosition, maxScrollPosition を初期化
							pianorollHScrollBar.scrollPosition = rootSp_PRoll.scrollRect.x;
							pianorollVScrollBar.scrollPosition = rootSp_PRoll.scrollRect.y;
							pianorollHScrollBar.maxScrollPosition = (PianoRoll.BEAT_WIDTH*4)*100 - pianoroll.width;
							pianorollVScrollBar.maxScrollPosition = PianoRoll.PIANOROLL_HEIGHT - pianoroll.height;
						}
					}
				}

	          public function setWarnings(e:Event):void {
	            warnings.text = player.getWarnings();
	          }

				public function play():void {
					var i:int; // for用
					var j:int; // for用
					var len:int; // for用
					var len2:int; // for用
					var e:MEvent; // for用
					var eventsOfTrack:Array; // for用
					var item:PianoRollItem;
					
					if (!player.isPlaying()) {
						if (player.isPaused()) m_timer.start(); // 1秒ごとに再生位置表示を更新するタイマーを起動
						player.play(input.text);
						playButton.label = "Pause";
					}
					else {
						player.pause();
						playButton.label = "Play";
						m_timer.stop();
					}

					var tracks:Array;
					{
						var sequencer:MSequencer;
						{
							var mml:MML;
							{
								mml = player.getMML();
							}
							
							sequencer = mml.getSequencer();
						}
						
						tracks = sequencer.getTrackArr();
					}
					
					/*{ // MEvent 列をダンプ
						len = tracks.length;
						for (i = 0 ; i < len ; i++ ) {
							trace("[track " + i + "]");
							trace(tracks[i].getEventsStr()); // デバッグ用
							trace("\n")
						}
					}*/
					
					_rootSp_PRoll_ref.itemLayer_ref.graphics.clear();
					{ // tracks[j] のノート(= PianoRollItem)の列を画面上に表示
						len2 = tracks.length;
						for (j = 0 ; j < len2 ; j++ ) {
							eventsOfTrack = tracks[j].getEvents();
							
							{
								var pianoRollItemArr:Array;
								{ // pianoRollItemArr を初期化。tracks[j] の MEvent 列をノート(= PianoRollItem)の列に変換
									pianoRollItemArr = new Array();
									{ // pianoRollItemArr にノート(= PianoRollItem)を push していく
										len = eventsOfTrack.length;
										for (i = 0 ; i < len ; i++ ) { // MEvent インスタンスを順次走査
											e = eventsOfTrack[i];
											if (e.getTick() > 38400) { break; } // 1-origin で101小節目以降のイベントは無視する
											switch(e.getStatus()) { // TODO: test-driven で異常系を実装する
												case MStatus.NOTE_ON:
													item = new PianoRollItem();
													item.startPosInTick = e.getTick();
													item.startPitch = e.getNoteNo()*100;
													item.velocity = e.getVelocity();
													break;
												case MStatus.NOTE_OFF:
													item.endPosInTick = e.getTick();
													pianoRollItemArr.push(item);
													break;
												case MStatus.DETUNE: // TODO: DETUNE によるノートの音高変化に対応
												default:
													break;
											}
										}
									}
								}
								
								//できたノート(= PianoRollItem)列をダンプ
								//trace(pianoRollItemArr);
								
								_rootSp_PRoll_ref.itemLayer_ref.graphics.lineStyle(2, (64+Math.floor(Math.random()*192))*0x10000 + (64+Math.floor(Math.random()*192))*0x100 + (64+Math.floor(Math.random()*192)));
								{
									len = pianoRollItemArr.length;
									for (i = 0 ; i < len ; i++ ) { // MEvent インスタンスを順次走査
										var item2:PianoRollItem = pianoRollItemArr[i];
										
										{ // ノートを配置
											_rootSp_PRoll_ref.itemLayer_ref.graphics.moveTo(
												Number(PianoRoll.BEAT_WIDTH) * (Number(item2.startPosInTick) / 96.0),
												Number(PianoRoll.SEMITONE_HEIGHT) * (128.0 - (Number(item2.startPitch) / 100.0))
											);
											_rootSp_PRoll_ref.itemLayer_ref.graphics.lineTo(
												Number(PianoRoll.BEAT_WIDTH) * (Number(item2.endPosInTick) / 96.0),
												Number(PianoRoll.SEMITONE_HEIGHT) * (128.0 - (Number(item2.startPitch) / 100.0))
											);
										}
									}
				
								}
							}
							
						}
					}
					
				}

	          public function stop():void {
	            player.stop();
	            playButton.label = "Play";
	            m_timer.reset();
	            progress.text = "";
				  voiceCount.text = "";
	          }

	          public function onComplete(e:Event):void {
	            playButton.label = "Play";
	            m_timer.reset();
	            progress.text = "";
				  voiceCount.text = "";
	          }

	          public function onBuffering(e:MMLEvent):void {
	            if (e.progress < 100) {
					  progress.text = "Buffering " + e.progress + "%";
					  voiceCount.text = "";
	            } else {
	              onSecond(e);
	              m_timer.start();
	            }
	          }

	          public function onSecond(e:Event):void {
	            progress.text = player.getNowTimeStr() + " / " + player.getTotalTimeStr();
				  //voiceCount.text = "♪" + player.getVoiceCount();
	          }
	      ]]>
	</mx:Script>

	<mx:Panel title="FlMML" width="100%" height="100%"
	          paddingTop="4" paddingBottom="4" paddingLeft="4" paddingRight="4">
	    <mx:VBox label="MML" width="100%" height="100%"
	                   paddingTop="4" paddingBottom="4" paddingLeft="4" paddingRight="4">
	      <mx:VDividedBox width="100%" height="100%" backgroundColor="#dddddd">
	        <mx:TextArea id="input" width="100%" height="2%" fontSize="14" text="L8 O5CDEFGAB&lt;C"></mx:TextArea>
			<mx:Grid width="100%" height="96%" horizontalGap="0" verticalGap="0" backgroundColor="#ffdddd">
				<mx:GridRow width="100%">
					<mx:GridItem backgroundColor="#0080C0">
					</mx:GridItem>
					<mx:GridItem height="48">
						<!--小節数--><mx:Image></mx:Image>
					</mx:GridItem>
					<mx:GridItem backgroundColor="#0080C0">
					</mx:GridItem>
				</mx:GridRow>

				<mx:GridRow width="100%" height="100%">
					<mx:GridItem width="120">
						<!--鍵盤--><mx:Image></mx:Image>
					</mx:GridItem>
					<mx:GridItem width="100%" height="100%">
						<!--ピアノロール--><flmon:FocusImage id="pianoroll" width="100%" height="100%"></flmon:FocusImage>
					</mx:GridItem>
					<mx:GridItem backgroundColor="#ffffff">
						<!--縦スクロールバー--><mx:VScrollBar id="pianorollVScrollBar" height="100%"
										minScrollPosition="0" maxScrollPosition="0" scrollPosition="0"
										pageSize="{pianoroll.height}"
										lineScrollSize="20" pageScrollSize="{pianoroll.height}" 
										repeatDelay="0" repeatInterval="0"
										scroll="_rootSp_PRoll_ref.scrollRect = new Rectangle(_rootSp_PRoll_ref.scrollRect.x, pianorollVScrollBar.scrollPosition, pianoroll.width, pianoroll.height);" />
					</mx:GridItem>
				</mx:GridRow>

				<mx:GridRow width="100%">
					<mx:GridItem backgroundColor="#0080C0">
					</mx:GridItem>
					<mx:GridItem backgroundColor="#ffffff">
						<!--横スクロールバー--><mx:HScrollBar id="pianorollHScrollBar" width="100%"
										minScrollPosition="0" maxScrollPosition="0" scrollPosition="0"
										pageSize="{pianoroll.width}"
										lineScrollSize="20" pageScrollSize="{pianoroll.width}" 
										repeatDelay="0" repeatInterval="0"
										scroll="_rootSp_PRoll_ref.scrollRect = new Rectangle(pianorollHScrollBar.scrollPosition, _rootSp_PRoll_ref.scrollRect.y, pianoroll.width, pianoroll.height)" />
					</mx:GridItem>
					<mx:GridItem backgroundColor="#0080C0">
					</mx:GridItem>
				</mx:GridRow>
			</mx:Grid>
	        <mx:TextArea id="warnings" width="100%" height="2%" fontSize="10" editable="false">
	          <mx:text></mx:text>
	        </mx:TextArea>
	      </mx:VDividedBox>
	      <mx:Box direction="horizontal">
	        <mx:Button id="playButton" label="Play" click="play();" />
	        <mx:Button id="stopButton" label="Stop" click="stop();" />
	        <mx:HSlider id="hSlider" minimum="0" maximum="127" value="100"
	                    dataTipPlacement="top" tickColor="black" snapInterval="1"
	                    allowTrackClick="true" liveDragging="true"
	                    change="player.setMasterVolume(hSlider.value);"/>
	        <mx:Label id="progress" text="" />
	        <mx:Label id="voiceCount" text="" />
	      </mx:Box>
	      <flmml:FlMML id="player" />
	    </mx:VBox>
	</mx:Panel>

</mx:Application>
