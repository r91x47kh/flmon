<?xml version="1.0" encoding="utf-8"?>

<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml"
                xmlns:flmml="com.txt_nifty.sketch.flmml.*"
                xmlns:flmon="net.vt6f3ohw.flmon.*"
                layout="absolute"
				frameRate="60"
				horizontalScrollPolicy="off" verticalScrollPolicy="off"
				creationComplete="init();">
    <mx:Style>
        @namespace mx "http://www.adobe.com/2006/mxml";
        mx|TextArea {
            fontFamily: "_typewriter","ＭＳ ゴシック","平成角ゴシック","monospace";
            fontSize: 14pt;
        }
    </mx:Style>

	<mx:Script>
	  <![CDATA[
				import com.txt_nifty.sketch.flmml.MEvent;
				import com.txt_nifty.sketch.flmml.MStatus
				import com.txt_nifty.sketch.flmml.MML;
				import com.txt_nifty.sketch.flmml.MMLEvent;
				import com.txt_nifty.sketch.flmml.MSequencer;
				import flash.events.Event;
				import flash.events.KeyboardEvent;
				import flash.events.FocusEvent;
				import flash.media.Sound;
				import flash.ui.Keyboard;
				import flash.geom.Rectangle;
				import flash.display.Graphics;
				import flash.display.Sprite;
				import flash.text.TextField;
				import flash.media.SoundChannel;
				import net.vt6f3ohw.flmon.ColorSet;
				import net.vt6f3ohw.flmon.KeyBoardPanel;
				import net.vt6f3ohw.flmon.PianoRoll;
				import net.vt6f3ohw.flmon.PianoRollItem;
				import net.vt6f3ohw.flmon.Util;
				
				protected var m_timer:Timer;
				
				
				// TODO: コンフィグを可能にする
				// 　　・「再生ボタンを押した時の巻き戻し」をON/OFFできるようにする
				// 　　・「オートスクロールモード」を「常時スクロール」「ページ単位スクロール」のどちらか好きな方に設定できるようにする
				
			  
				// 定数たち
				
				// Sprite製UI部品たち
				
				private var _rootSp_KBoard_ref:KeyBoardPanel; // root となる Sprite
				private var _mask_KBoard_ref:Sprite; // マスク
				
				private var _rootSp_PRoll_ref:PianoRoll; // root となる Sprite
					private var _frameCounterText_ref:TextField;
					private var _soundChannelPositionText_ref:TextField;
				private var _mask_PRoll_ref:Sprite; // マスク
				
				// UI操作用変数たち
				/** 現在のフレームの_positionXInPixel */
				private var _positionXInPixel:Number;
				/** 1フレーム前の _positionXInPixel */
				private var _positionXInPixel_prev:Number; 
				/** オートスクロールの際の毎フレームでのスクロール量を格納するキュー */
				private var _absoluteScrollQueue:Array = new Array();
				/** [ユーティリティ関数] ピアノロールを (x, y) にスクロールする*/
				private var _absoluteScroll:Function = function(x:int, y:int):void {
					var rect:Rectangle;
					{
						rect = _rootSp_PRoll_ref.scrollRect.clone();
						rect.x = x;
						rect.y = y;
						if (rect.x < 0) rect.x = 0; // 画面左端以降にスクロールしようとしていたらクリッピング
						if (rect.y < 0) rect.y = 0; // 画面上端以降にスクロールしようとしていたらクリッピング
						if (rect.x + rect.width > (PianoRoll.BEAT_WIDTH*4)*100) rect.x = (PianoRoll.BEAT_WIDTH*4)*100 - rect.width; // 画面右端以降にスクロールしようとしていたらクリッピング
						if (rect.y + rect.height > PianoRoll.PIANOROLL_HEIGHT) rect.y = PianoRoll.PIANOROLL_HEIGHT - rect.height; // 画面下端以降にスクロールしようとしていたらクリッピング
					}
					
					_rootSp_PRoll_ref.scrollRect = rect;
				};
				/** [ユーティリティ関数] ピアノロールを (deltaX, deltaY) だけスクロールする*/
				private var _relativeScroll:Function = function(deltaX:int, deltaY:int):void {
					_absoluteScroll(_rootSp_PRoll_ref.scrollRect.x + deltaX, _rootSp_PRoll_ref.scrollRect.y + deltaY);
				};
							
				
				// カウンタたち
				private var frameCounter:uint = 0;
				
				// 再生情報取得用変数たち
				/** MSequencerインスタンスへの参照 */
				private var _sequencer_ref:MSequencer = null;
				/** テンポ境界における「再生位置[ms]」「再生位置[tick]」「後続のテンポ」の情報の列 */
				private var _tempoEntries_ref:Array;
				/** 再生位置[ms]に対応する再生位置[tick]を返す。*/
				private var _msToTick:Function = function(ms:Number):Number {
					var i:uint; // for用
					var len:uint; // for
					
					if (ms <= 0.0) return 0.0; // 変な入力に対処
					
					//trace(_tempoEntries_ref);
					//trace(_tempoEntries_ref[0]);
					//trace(_tempoEntries_ref[0]["ms"]);
					//trace(_tempoEntries_ref[0]["tick"]);
					//trace(_tempoEntries_ref[0]["tempo"]);
					//trace(2)
					len = _tempoEntries_ref.length;
					for (i = 0 ; i < len ; i++ ) { // tempo boundary entry を順次走査
						// [!!!] 同じ再生位置[tick]に tenpo boundary entry が2つ以上あるケースに注意 [!!!]

						// 「与えられた再生位置[ms]におけるテンポ」と、「その直前のテンポ境界の再生位置[tick]」を取得する
						if (ms <= _tempoEntries_ref[i]["ms"]) { // 初めて再生位置[ms]の大きなエントリに遭遇したら（ここは < でも <= でも結果は変わらない）
							return _tempoEntries_ref[i - 1]["tick"] + (ms - _tempoEntries_ref[i - 1]["ms"]) * (_tempoEntries_ref[i - 1]["tempo"] / 60.0 / 1000.0 * 96.0);
						}
					}
					
					// 与えられた再生位置[ms]が全てのテンポ境界よりも後にあった場合
					return _tempoEntries_ref[len - 1]["tick"] + (ms - _tempoEntries_ref[len - 1]["ms"]) * (_tempoEntries_ref[len - 1]["tempo"] / 60.0 / 1000.0 * 96.0);
			};
				
				// キー入力状態
				private var _isKeyPressed:Object = new Object(); // _isKeyPressed[Keyboard.XX] にキーの押下状態を保持

				public function init():void {
					var i:Number; // for用
					  
					if (this.parameters["mml"] != undefined) // mmlパラメータが渡されていたらMML入力欄にそれを置いておく
						input.text = unescape(this.parameters["mml"]);

					player.addEventListener(MMLEvent.COMPILE_COMPLETE, setWarnings);
					player.addEventListener(MMLEvent.COMPLETE,         onComplete);
					player.addEventListener(MMLEvent.BUFFERING,        onBuffering);
					
					m_timer = new Timer(250*4, 0); // 「1秒ごとに」「無限回」繰り返す
					m_timer.addEventListener(TimerEvent.TIMER, onSecond);

					{ // UIの用意
						{ // 小節数表示部分のUIの準備
							;
						}
						{ // 鍵盤部分のUIの準備
							{ // 描画が mx:Image 外にはみ出さないように、mx:Image にマスクを設定
								var mask_KBoard:Sprite;
								{ // mask_KBoard の初期化
									mask_KBoard = new Sprite();
									mask_KBoard.cacheAsBitmap = true; // 描画結果（＝ビットマップ）をキャッシュして高速化
									mask_KBoard.graphics.beginFill(0x000000);
									mask_KBoard.graphics.drawRect(0, 0, kboard.width, kboard.height);
									mask_KBoard.graphics.endFill();
								}
								_mask_KBoard_ref = mask_KBoard;
								
								kboard.addChild(mask_KBoard); // マスクをかける位置は動的に変化するため、addChild しておかないとマスクの位置がズレるので注意
								kboard.mask = mask_KBoard;
							}
							{ // mx:Image の中に Sprite ツリーを投入
								var rootSp_KBoard:KeyBoardPanel; // mx:Image の中で root となる Sprite
								{ // rootSp_KBoard の初期化
									rootSp_KBoard = new KeyBoardPanel();
									rootSp_KBoard.scrollRect = new Rectangle(0, PianoRoll.SEMITONE_HEIGHT*36, kboard.width, kboard.height); // デフォルトのスクロール位置とビューポートのサイズを設定
								}
								_rootSp_KBoard_ref = rootSp_KBoard;
								
								kboard.addChild(rootSp_KBoard);
							}
							kboard.addEventListener(Event.RESIZE, function(e:Event):void { // ピアノロールのサイズが変わった場合に備えてイベントハンドラを設定
								{ // マスク矩形のサイズを更新
									_mask_KBoard_ref.graphics.clear();
									_mask_KBoard_ref.graphics.beginFill(0x000000);
									_mask_KBoard_ref.graphics.drawRect(0, 0, kboard.width, kboard.height);
									_mask_KBoard_ref.graphics.endFill();
								}
								{ // 鍵盤部分のビューポートのサイズを更新
									var rect:Rectangle;
									{
										rect = _rootSp_KBoard_ref.scrollRect.clone();
										rect.width = kboard.width;
										rect.height = kboard.height;
									}
									
									_rootSp_KBoard_ref.scrollRect = rect;
								}
							});
						}
						{ // ピアノロール部分のUIの準備
							{ // 描画が mx:Image 外にはみ出さないように、mx:Image にマスクを設定
								var mask_PRoll:Sprite;
								{ // mask_PRoll の初期化
									mask_PRoll = new Sprite();
									mask_PRoll.cacheAsBitmap = true; // 描画結果（＝ビットマップ）をキャッシュして高速化
									mask_PRoll.graphics.beginFill(0x000000);
									mask_PRoll.graphics.drawRect(0, 0, pianoroll.width, pianoroll.height);
									mask_PRoll.graphics.endFill();
								}
								_mask_PRoll_ref = mask_PRoll;
								
								pianoroll.addChild(mask_PRoll); // マスクをかける位置は動的に変化するため、addChild しておかないとマスクの位置がズレるので注意
								pianoroll.mask = mask_PRoll;
							}
							{ // mx:Image の中に Sprite ツリーを投入
								var rootSp_PRoll:PianoRoll; // mx:Image の中で root となる Sprite
								{ // rootSp_PRoll の初期化
									rootSp_PRoll = new PianoRoll();
									rootSp_PRoll.scrollRect = new Rectangle(0, PianoRoll.SEMITONE_HEIGHT*36, pianoroll.width, pianoroll.height); // デフォルトのスクロール位置とビューポートのサイズを設定
									{ // rootSp_PRoll に子Sprite （フレームカウントを表示するTextField）を追加
										var frameCounterText:TextField;
										{
											frameCounterText = new TextField();
											frameCounterText.x = 20;
											frameCounterText.y = 20;
											frameCounterText.width = 400;
											frameCounterText.height = 60;
											
											// デバッグ時は true にする
											//frameCounterText.visible = true;
											frameCounterText.visible = false;
										}
										_frameCounterText_ref = frameCounterText; // 参照のプール
										
										rootSp_PRoll.addChild(frameCounterText);
									}
									{ // rootSp_PRoll に子Sprite （再生位置を表示するTextField）を追加
										var soundChannelPositionText:TextField;
										{
											soundChannelPositionText = new TextField();
											soundChannelPositionText.x = 20;
											soundChannelPositionText.y = 60;
											soundChannelPositionText.width = 400;
											soundChannelPositionText.height = 60;
											
											// デバッグ時は true にする
											//soundChannelPositionText.visible = true;
											soundChannelPositionText.visible = false;
										}
										_soundChannelPositionText_ref = soundChannelPositionText; // 参照のプール
										
										rootSp_PRoll.addChild(soundChannelPositionText);
									}
									rootSp_PRoll.addEventListener(Event.ENTER_FRAME, function(e:Event):void { // デバッグ用。フレームカウンタを表示
										{ // フレームカウント文字列を更新
											_frameCounterText_ref.text = "frame count: " + (++frameCounter).toString();
										}
										{ // 再生位置文字列を更新
											if (_sequencer_ref != null) {
												//trace(Util.getInstanceID(_sequencer_ref.getSoundChannel()));
												
												// ここ、ちゃんと毎回 _sequencer_ref.getSoundChannel() しないと
												// 「position がずっと変化しない SoundChannel インスタンス」に遭遇するので注意（原因不明）
												_soundChannelPositionText_ref.text = "sound channel position: " + _sequencer_ref.getSoundChannel().position.toString();
											}
										}
										{ // ピアノロールのスクロール位置を更新											
											{
												var isScrolled:Boolean = false; // scrollRect が変化したかどうかを格納するBoolean
												
												// 各キーが押下状態にあったらスクロール。また、オートスクロール中に左右キーが押された場合はオートスクロールを中断
												if (_isKeyPressed[Keyboard.UP] != undefined && _isKeyPressed[Keyboard.UP]) { _relativeScroll(0, -20); isScrolled = true; }
												if (_isKeyPressed[Keyboard.DOWN] != undefined && _isKeyPressed[Keyboard.DOWN]) { _relativeScroll(0, 20); isScrolled = true; }
												if (_isKeyPressed[Keyboard.LEFT] != undefined && _isKeyPressed[Keyboard.LEFT]) { _relativeScroll( -20, 0); isScrolled = true; _absoluteScrollQueue.length = 0; }
												if (_isKeyPressed[Keyboard.RIGHT] != undefined && _isKeyPressed[Keyboard.RIGHT]) { _relativeScroll(20, 0); isScrolled = true; _absoluteScrollQueue.length = 0; }
												
												// scrollRect が変化していたら Event.SCROLL イベントを dispatch
												if(isScrolled){ rootSp_PRoll.dispatchEvent(new Event(Event.SCROLL)); }
											}
										}
										{ // 再生位置バーを更新＋再生位置バーに応じてオートスクロールをキュー
											rootSp_PRoll.playingPositionBarLayer_ref.graphics.clear();
											if (_sequencer_ref != null) { // 一応nullチェック
												var soundChannel:SoundChannel = _sequencer_ref.getSoundChannel();
												
												// 再生中かポーズ中のときのみ再生位置バーを表示
												if (_sequencer_ref.isPlaying() || _sequencer_ref.isPaused()) {
													if(soundChannel != null){ // 一応nullチェック
														{
															{
																// TODO: 「1回目はpositionXInPixel_prev に未定義の値が入る」問題に一応対処
																_positionXInPixel_prev = _positionXInPixel; // _positionXInPixel を更新する前に _positionXInPixel_prev にバックアップ
																_positionXInPixel = Number(PianoRoll.BEAT_WIDTH) * (_msToTick(_sequencer_ref.getSoundChannel().position) / 96.0);
															}
															
															rootSp_PRoll.playingPositionBarLayer_ref.graphics.lineStyle(4, 0x333333, 0.5);
															rootSp_PRoll.playingPositionBarLayer_ref.graphics.moveTo(_positionXInPixel, 0);
															rootSp_PRoll.playingPositionBarLayer_ref.graphics.lineTo(_positionXInPixel, PianoRoll.PIANOROLL_HEIGHT);
															
															{ // 一定の条件が満たされたときにオートスクロールをキューする
																// オートスクロールが有効で、かつオートスクロール中でないときのみ新たにオートスクロールする
																if (autoScrollCheckBox.selected && _absoluteScrollQueue.length == 0) {
																	var ACTIVATION_WIDTH:Number = PianoRoll.BEAT_WIDTH * 4; // 画面右端から何pixelの所をまたいだらオートスクロールするか
																	
																	trace("_positionXInPixel_prev = " + _positionXInPixel_prev + ", _positionXInPixel = " + _positionXInPixel);
																	// 再生位置バーが画面右端から ACTIVATION_WIDTH pixel の地点をまたいだらオートスクロール
																	if (_positionXInPixel_prev < rootSp_PRoll.scrollRect.x + rootSp_PRoll.width - ACTIVATION_WIDTH
																		&& rootSp_PRoll.scrollRect.x + rootSp_PRoll.width - ACTIVATION_WIDTH <= _positionXInPixel) { // 再生位置バーが画面右端から ACTIVATION_WIDTH pixel の地点にピッタリ到達してしまう場合に対処して「<」ではなく「<=」にしておく
																		//trace("stepped over");
																		
																		var DURATION_IN_FRAME:Number = 60.0; // 何フレームで動かすか
																		for (i = 1.0 ; i <= DURATION_IN_FRAME ; i += 1.0) {
																			var absoluteScrollEntry:Object; // スクロール先の絶対座標を保持するエントリ
																			{
																				absoluteScrollEntry = new Object(); // absoluteScrollEntry["scrollTo_x"] のみを要素に持つ連想配列
																				absoluteScrollEntry["scrollTo_x"] = Util.easeInOut_Quadratic(i, rootSp_PRoll.scrollRect.x, rootSp_PRoll.width - ACTIVATION_WIDTH, DURATION_IN_FRAME);
																			}
																			
																			_absoluteScrollQueue.push(absoluteScrollEntry);
																		}	
																	}
																}
															}
														}
													}
												}
											}
										}
										{ // オートスクロールを処理
											if (_absoluteScrollQueue.length > 0) {
												var absoluteScrollEntry2:Object = _absoluteScrollQueue.shift();
												
												_absoluteScroll(absoluteScrollEntry2["scrollTo_x"], _rootSp_PRoll_ref.scrollRect.y);
												rootSp_PRoll.dispatchEvent(new Event(Event.SCROLL)); // Event.SCROLL イベントを dispatch
											}
										}
									});
									rootSp_PRoll.addEventListener(Event.SCROLL, function(e:Event):void { // rootSp_PRoll.scrollRect が変化したときに呼ばれるハンドラ
										pianorollHScrollBar.scrollPosition = rootSp_PRoll.scrollRect.x;
										pianorollVScrollBar.scrollPosition = rootSp_PRoll.scrollRect.y;
										{ // 「鍵盤Spriteのy方向のクリッピング位置」を「ピアノロールSpriteのy方向のクリッピング位置」と同期
											var rect:Rectangle;
											{
												rect = _rootSp_KBoard_ref.scrollRect.clone();
												rect.y = _rootSp_PRoll_ref.scrollRect.y;
											}
											
											_rootSp_KBoard_ref.scrollRect = rect;
										}
									});
								}
								_rootSp_PRoll_ref = rootSp_PRoll; // 参照のプール
								
								pianoroll.addChild(rootSp_PRoll);
							}
							pianoroll.addEventListener(Event.RESIZE, function(e:Event):void { // ピアノロールのサイズが変わった場合に備えてイベントハンドラを設定
								{ // マスク矩形のサイズを更新
									_mask_PRoll_ref.graphics.clear();
									_mask_PRoll_ref.graphics.beginFill(0x000000);
									_mask_PRoll_ref.graphics.drawRect(0, 0, pianoroll.width, pianoroll.height);
									_mask_PRoll_ref.graphics.endFill();
								}
								{ // ピアノロールのビューポートのサイズを更新
									var rect:Rectangle;
									{
										rect = _rootSp_PRoll_ref.scrollRect.clone();
										rect.width = pianoroll.width;
										rect.height = pianoroll.height;
									}
									
									_rootSp_PRoll_ref.scrollRect = rect;
								}
								{ // 縦横スクロールバーの pageSize を更新（不要？）
									pianorollHScrollBar.pageSize = pianoroll.width;
									pianorollVScrollBar.pageSize = pianoroll.height;
								}
								{ // 縦横スクロールバーの maxScrollPosition を更新
									pianorollHScrollBar.maxScrollPosition = (PianoRoll.BEAT_WIDTH*4)*100 - pianoroll.width;
									pianorollVScrollBar.maxScrollPosition = PianoRoll.PIANOROLL_HEIGHT - pianoroll.height;
								}
							});
							pianoroll.addEventListener(KeyboardEvent.KEY_DOWN, function(e2:KeyboardEvent):void {
								_isKeyPressed[e2.keyCode] = true;
							});
							pianoroll.addEventListener(KeyboardEvent.KEY_UP, function(e2:KeyboardEvent):void {
								_isKeyPressed[e2.keyCode] = false;
							});
							pianoroll.addEventListener(MouseEvent.MOUSE_WHEEL, function(e3:MouseEvent):void {
								var delta:int = e3.delta; // ホイールの回転量

								_relativeScroll(0, PianoRoll.SEMITONE_HEIGHT * ( -delta )); // (半音の縦幅)*(ホイールの回転量)ずつスクロール（スクロールの向きは指を動かす方向と同じ）
								rootSp_PRoll.dispatchEvent(new Event(Event.SCROLL)); // Event.SCROLL イベントを dispatch
							});
							// TODO: キー押下状態中にフォーカスがどっか行ったときに備えて FocusEvent.OUT 時にキー押下状態を全部 false にするコードを追加
							// pianoroll.addEventListener(FocusEvent.FOCUS_OUT, function(e3:FocusEvent):void {
							// 	trace(e3);
							// });
						}
						{ // 縦横スクロールバーの scrollPosition, maxScrollPosition を初期化
							pianorollHScrollBar.scrollPosition = rootSp_PRoll.scrollRect.x;
							pianorollVScrollBar.scrollPosition = rootSp_PRoll.scrollRect.y;
							pianorollHScrollBar.maxScrollPosition = (PianoRoll.BEAT_WIDTH*4)*100 - pianoroll.width;
							pianorollVScrollBar.maxScrollPosition = PianoRoll.PIANOROLL_HEIGHT - pianoroll.height;
						}
					}
				}

	          public function setWarnings(e:Event):void {
	            warnings.text = player.getWarnings();
	          }

				public function play():void {
					var i:int; // for用
					var j:int; // for用
					var len:int; // for用
					var len2:int; // for用
					var e:MEvent; // for用
					var eventsOfTrack:Array; // for用
					var item:PianoRollItem;
					
					if (!player.isPlaying()) {
						if (player.isPaused()) {
							m_timer.start(); // 1秒ごとに再生位置表示を更新するタイマーを起動
						}else {
							if(rewindOnPlayCheckBox.selected){ // 「新規再生時に最初まで巻き戻し」が有効なときに新規再生が起きたらオートスクロールをキューする
								_absoluteScrollQueue.length　= 0; // オートスクロール中だったらそのオートスクロールを中断する
								{
									var DURATION_IN_FRAME:Number = 60.0; // 何フレームで動かすか
									for (i = 1.0 ; i <= DURATION_IN_FRAME ; i += 1.0) {
										var absoluteScrollEntry:Object; // スクロール先の絶対座標を保持するエントリ
										{
											absoluteScrollEntry = new Object(); // absoluteScrollEntry["scrollTo_x"] のみを要素に持つ連想配列
											absoluteScrollEntry["scrollTo_x"] = Util.easeInOut_Quadratic(i, _rootSp_PRoll_ref.scrollRect.x, -_rootSp_PRoll_ref.scrollRect.x, DURATION_IN_FRAME);
										}
										
										_absoluteScrollQueue.push(absoluteScrollEntry);
									}
								}
							}
						}
						
						player.play(input.text);
						playButton.label = "Pause";

						var tracks:Array;
						{ // tracks を初期化（その過程で MML インスタンスと MSequencer インスタンスを取得）
							var sequencer:MSequencer;
							{ // MSequencer インスタンスを取得
								var mml:MML;
								{ // MML インスタンスを取得
									mml = player.getMML();
								}
								
								sequencer = mml.getSequencer();
							}
							_sequencer_ref = sequencer;
							
							tracks = sequencer.getTrackArr();
						}
						/*{ // MEvent 列をダンプ
							len = tracks.length;
							for (i = 0 ; i < len ; i++ ) {
								trace("[track " + i + "]");
								trace(tracks[i].getEventsStr()); // デバッグ用
								trace("\n")
							}
						}*/
						{ // tempo boundary entry(= テンポ境界の情報)の列を MEvent.TEMPO イベントの列から生成
							var tempoBoundaryEntries:Array; // tempo boundary entry(= テンポ境界の情報)の列
							{
								var eventsOfTempoTrack:Array = tracks[0].getEvents();
								// trace("[track " + 0 + "]"); // テンポトラックのMEvent列をダンプ
								// trace(tracks[0].getEventsStr());
								// trace("\n");
								
								tempoBoundaryEntries = new Array();
								{ // テンポ境界における「再生位置[tick]」「後続のテンポ」を取得
									//trace(eventsOfTempoTrack.length);
									len = eventsOfTempoTrack.length;
									for (i = 0 ; i < len ; i++ ) { // MEvent インスタンスを順次走査
										e = eventsOfTempoTrack[i];
										if (e.getTick() > 38400) { break; } // 1-origin で101小節目以降のイベントは無視する
										switch(e.getStatus()) {
											case MStatus.TEMPO:
												//trace(i);
												var tempoBoundaryEntry:Object;
												{
													tempoBoundaryEntry = new Object();
													tempoBoundaryEntry["ms"] = 0.0; // 一応初期化しておく
													tempoBoundaryEntry["tick"] = e.getTick();
													tempoBoundaryEntry["tempo"] = e.getTempo();
												}
												
												//trace(tempoBoundaryEntry);
												tempoBoundaryEntries.push(tempoBoundaryEntry);
												break;
											default:
												break;
										}
									}
									if (tempoBoundaryEntries.length == 0) { // テンポトラックにTEMPOイベントが全くなくて tempo boundary entry 列が空列になった場合
										// デフォルトのテンポを持った tempo boundary entry を1個仕込む（これを入れないとテンポ境界情報が全くなくなるためバグる）
										var tempoBoundaryEntry2:Object;
										{
											tempoBoundaryEntry2 = new Object();
											tempoBoundaryEntry2["ms"] = 0.0;
											tempoBoundaryEntry2["tick"] = 0;
											tempoBoundaryEntry2["tempo"] = 120.0;
										}
										
										tempoBoundaryEntries.push(tempoBoundaryEntry2);
									}
								}
								{ // 各テンポ境界における「再生位置[tick]」「後続のテンポ」から、各テンポ境界における「再生位置[ms]」を計算
									len = tempoBoundaryEntries.length;
									for (i = 0 ; i < len ; i++ ) { // MEvent インスタンスを順次走査
										if (i == 0) {
											tempoBoundaryEntries[0]["ms"] = 0.0; // 特例
											//trace("ms: "+tempoBoundaryEntries[i]["ms"]);
											//trace("tick: "+tempoBoundaryEntries[i]["tick"]);
											//trace("tempo: "+tempoBoundaryEntries[i]["tempo"]);
											continue;
										}else {
											// 前のエントリの ms, tick, tempo と現在のエントリの tick を使って、現在のエントリの ms を計算
											tempoBoundaryEntries[i]["ms"]
												= tempoBoundaryEntries[i - 1]["ms"]
												   + (tempoBoundaryEntries[i]["tick"] - tempoBoundaryEntries[i - 1]["tick"]) /* [tick] */
												   / 96.0 /* [tick/beat] */
												   / tempoBoundaryEntries[i - 1]["tempo"] /* [beat/min] */
												   * 60000.0 /* [ms/min] */;
											//trace("ms: "+tempoBoundaryEntries[i]["ms"]);
											//trace("tick: "+tempoBoundaryEntries[i]["tick"]);
											//trace("tempo: "+tempoBoundaryEntries[i]["tempo"]);
										}
									}
								}
							}
							_tempoEntries_ref = tempoBoundaryEntries; // 参照のプール
							
							// tempoBoundaryEntries はここでは使わない。_tempoEntries_ref　に入れたらここでは用済み
						}
						{ // tracks[j] のノート(= PianoRollItem)の列を画面上に表示
							var colorSet:ColorSet = new ColorSet(); // 
							
							_rootSp_PRoll_ref.itemLayer_ref.graphics.clear(); // まずレイヤ上の描画オブジェクトをクリア
							{
								len2 = tracks.length;
								for (j = 0 ; j < len2 ; j++ ) {
									eventsOfTrack = tracks[j].getEvents();
									
									{
										var pianoRollItemArr:Array;
										{ // pianoRollItemArr を初期化。tracks[j] の MEvent 列をノート(= PianoRollItem)の列に変換
											pianoRollItemArr = new Array();
											{ // pianoRollItemArr にノート(= PianoRollItem)を push していく
												len = eventsOfTrack.length;
												for (i = 0 ; i < len ; i++ ) { // MEvent インスタンスを順次走査
													e = eventsOfTrack[i];
													if (e.getTick() > 38400) { break; } // 1-origin で101小節目以降のイベントは無視する
													switch(e.getStatus()) { // TODO: test-driven で異常系を実装する
														case MStatus.NOTE_ON:
															item = new PianoRollItem();
															item.startPosInTick = e.getTick();
															item.startPitch = e.getNoteNo()*100;
															item.velocity = e.getVelocity();
															break;
														case MStatus.NOTE_OFF:
															item.endPosInTick = e.getTick();
															pianoRollItemArr.push(item);
															break;
														case MStatus.DETUNE: // TODO: DETUNE によるノートの音高変化に対応
														default:
															break;
													}
												}
											}
										}
										
										//できたノート(= PianoRollItem)列をダンプ
										//trace(pianoRollItemArr);
										
										colorSet.h = (240/*←青スタート*/ -/*←「青→水色→黄緑→黄→橙→赤→紫」の順に辿るためマイナスを指定*/ (30*j)/*←色相を12ステップで1周*/) % 360; // 色相（hue）
										colorSet.s = 100; // 彩度（Saturation）
										colorSet.v = 80; // 明度（Value）
										_rootSp_PRoll_ref.itemLayer_ref.graphics.lineStyle(2, colorSet.c);
										{
											len = pianoRollItemArr.length;
											for (i = 0 ; i < len ; i++ ) { // MEvent インスタンスを順次走査
												var item2:PianoRollItem = pianoRollItemArr[i];
												
												{ // ノートを配置
													_rootSp_PRoll_ref.itemLayer_ref.graphics.moveTo(
														Number(PianoRoll.BEAT_WIDTH) * (Number(item2.startPosInTick) / 96.0),
														Number(PianoRoll.SEMITONE_HEIGHT) * (128.0 - (Number(item2.startPitch) / 100.0))
													);
													_rootSp_PRoll_ref.itemLayer_ref.graphics.lineTo(
														Number(PianoRoll.BEAT_WIDTH) * (Number(item2.endPosInTick) / 96.0),
														Number(PianoRoll.SEMITONE_HEIGHT) * (128.0 - (Number(item2.startPitch) / 100.0))
													);
												}
											}
						
										}
									}
									
								}
							}
						}
					}
					else {
						player.pause();
						playButton.label = "Play";
						m_timer.stop();
					}
				}

	          public function stop():void {
	            player.stop();
	            playButton.label = "Play";
	            m_timer.reset();
	            progress.text = "";
				  voiceCount.text = "";
	          }

	          public function onComplete(e:Event):void {
	            playButton.label = "Play";
	            m_timer.reset();
	            progress.text = "";
				  voiceCount.text = "";
	          }

	          public function onBuffering(e:MMLEvent):void {
	            if (e.progress < 100) {
					  progress.text = "Buffering " + e.progress + "%";
					  voiceCount.text = "";
	            } else {
	              onSecond(e);
	              m_timer.start();
	            }
	          }

	          public function onSecond(e:Event):void {
	            progress.text = player.getNowTimeStr() + " / " + player.getTotalTimeStr();
				//voiceCount.text = "♪" + player.getVoiceCount();
	          }
	      ]]>
	</mx:Script>

	<mx:Panel title="FlMMLMonitor Rev.1 (based on FlMML@CodePlex Commit 19253)" width="100%" height="100%"
	          paddingTop="4" paddingBottom="4" paddingLeft="4" paddingRight="4">
	    <mx:VBox width="100%" height="100%"
	                   paddingTop="4" paddingBottom="4" paddingLeft="4" paddingRight="4">
	      <mx:VDividedBox width="100%" height="100%" backgroundColor="#dddddd">
	        <mx:TextArea id="input" width="100%" height="4%" fontSize="14" text="L8 O5CDEFGAB&lt;C"></mx:TextArea>
			<mx:Grid width="100%" height="94%" horizontalGap="0" verticalGap="0" backgroundColor="#ffdddd">
				<mx:GridRow width="100%">
					<mx:GridItem backgroundColor="#0080C0">
					</mx:GridItem>
					<mx:GridItem height="48">
						<!--小節数--><mx:Image id="measureheader" width="100%" height="100%"></mx:Image>
					</mx:GridItem>
					<mx:GridItem backgroundColor="#0080C0">
					</mx:GridItem>
				</mx:GridRow>

				<mx:GridRow width="100%" height="100%">
					<mx:GridItem width="120">
						<!--鍵盤--><mx:Image id="kboard" width="100%" height="100%"></mx:Image>
					</mx:GridItem>
					<mx:GridItem width="100%" height="100%">
						<!--ピアノロール--><flmon:FocusImage id="pianoroll" width="100%" height="100%"></flmon:FocusImage>
					</mx:GridItem>
					<mx:GridItem backgroundColor="#ffffff">
						<!--縦スクロールバー--><mx:VScrollBar id="pianorollVScrollBar" height="100%"
										minScrollPosition="0" maxScrollPosition="0" scrollPosition="0"
										pageSize="{pianoroll.height}"
										lineScrollSize="20" pageScrollSize="{pianoroll.height}" 
										repeatDelay="0" repeatInterval="0"
										scroll="
										_absoluteScrollQueue.length = 0;
										_absoluteScroll(_rootSp_PRoll_ref.scrollRect.x, pianorollVScrollBar.scrollPosition);
										var rect:Rectangle;
										{
											rect = _rootSp_KBoard_ref.scrollRect.clone();
											rect.y = _rootSp_PRoll_ref.scrollRect.y;
										}
										_rootSp_KBoard_ref.scrollRect = rect;
										" />
					</mx:GridItem>
				</mx:GridRow>

				<mx:GridRow width="100%">
					<mx:GridItem backgroundColor="#0080C0">
					</mx:GridItem>
					<mx:GridItem backgroundColor="#ffffff">
						<!--横スクロールバー--><mx:HScrollBar id="pianorollHScrollBar" width="100%"
										minScrollPosition="0" maxScrollPosition="0" scrollPosition="0"
										pageSize="{pianoroll.width}"
										lineScrollSize="20" pageScrollSize="{pianoroll.width}" 
										repeatDelay="0" repeatInterval="0"
										scroll="
										_absoluteScrollQueue.length = 0;
										_absoluteScroll(pianorollHScrollBar.scrollPosition, _rootSp_PRoll_ref.scrollRect.y);
										" />
					</mx:GridItem>
					<mx:GridItem backgroundColor="#0080C0">
					</mx:GridItem>
				</mx:GridRow>
			</mx:Grid>
	        <mx:TextArea id="warnings" width="100%" height="2%" fontSize="10" editable="false">
	          <mx:text></mx:text>
	        </mx:TextArea>
	      </mx:VDividedBox>
	      <mx:Box direction="horizontal">
	        <mx:Button id="playButton" label="Play" click="play();" />
	        <mx:Button id="stopButton" label="Stop" click="stop();" />
	        <mx:HSlider id="hSlider" minimum="0" maximum="127" value="100"
	                    dataTipPlacement="top" tickColor="black" snapInterval="1"
	                    allowTrackClick="true" liveDragging="true"
	                    change="player.setMasterVolume(hSlider.value);"/>
	        <mx:Label id="progress" width="120" text="" />
	        <mx:Label id="voiceCount" width="60" text="" />
			<mx:CheckBox id="rewindOnPlayCheckBox" label="新規再生時に最初まで巻き戻す" selected="true"></mx:CheckBox>
			<mx:CheckBox id="autoScrollCheckBox" label="ページ単位でオートスクロール" selected="true"></mx:CheckBox>
	      </mx:Box>
	      <flmml:FlMML id="player" />
	    </mx:VBox>
	</mx:Panel>

</mx:Application>
